package core.grammar;

import java.util.Map;
import java.util.Collection;

/**
 *     
 *     The inteface declares the methods that define the responsabilities of a Derivation object.
 *      
 *     It belongs to the Public API.
 *     
 *     @author Jorge Couchet
 *     
 **/

public interface Derivation {
	
	
	/**
	 * 
	 * Returns a new Grammar's Derivation, using the symbol nt as the starting point, that is: the Productions
	 * that have nt as the left symbol are selected, and one of them is selected in a random way. Next, the
	 * Non Terminals at the right side of the Production selected, are used as starting point, an so on, until
	 * only Terminal symbols are generated and the Derivation is complete.
	 * 
	 * The method getRandomDerivation (without a maximum depth), isn't implemented because it can consume
	 * the machine's memory. But the method can be simulated with the method getMaxRandomDerivation with
	 * a big value in the parameter maxDepthGlobal.
	 * 
	 * It's important to note that the Derivation generated for the function have a depth's maximum (maxDepthGlobal),
	 * that is: the Productions are selected in a random way, but if the production selected generates a Derivation
	 * that surpasses the maxDepthGlobal, the Production selected and the Derivation generated are discarded and
	 * a new Production is selected.
	 * 
	 * The details of the algorithm used is given in the paper: "Crossover and Mutation Operators for 
	 * Grammar-Guided Genetic Programming", by the authors: Jorge Couchet, Daniel Manrique, Juan Ríos and Alfonso
	 * Rodríguez-Patón.
	 * 
	 * @param maxDepthGlobal
	 * 						 The depth's maximum that a Derivation is allow to reach.
	 * 
	 * @param nt
	 * 			 The Grammar's Non Terminal symbol used as starting point to generate a new Derivation.
	 * 
	 */
	public Derivation getMaxRandomDerivation(int maxDepthGlobal, NonTerminal nt) throws GrammarExceptionImpl, 
	                                                                                    GrammarMaxDepthExceptionImpl;
	
	
	/**
	 * 
	 * The function has the same behavior that the function "getMaxRandomDerivation", and it has been added with the 
	 * following additional feature: given an Element (e) with the symbol "s" associated, the function adds to the 
	 * Derivation's e node the following two items:
	 * 
	 * 1) A new function f, that is obtained through the parameter F ( F.createFunction ). The created function f
	 *    will be applied over the node.
	 * 2) A value (v) calculated in the following way: the e node is generated by a production P, where the 
	 *    e is at the right side. At the right side of P must be at least one Element more (e2), that must be a 
	 *    Terminal symbol. Then v is calculated as: v = features.get(e2.getSymbol). That is, the value is the double 
	 *    associated in the map "features" to the Element e2. The Element e2 is selected using the absolute position
	 *    s2_pos.
	 * 
	 * @param maxDepthGlobal
	 * 						 The depth's maximum that a Derivation is allow to reach.
	 * 
	 * @param nt
	 * 			 The Grammar's Non Terminal symbol used as starting point to generate a new Derivation.
	 * 
	 * @param features
	 * 					The mapping to be used to add the value v to the node that has an Element with a symbol "s".
	 * @param F
	 * 			The function f = F.createFunction will be added to the node that has an Element with a symbol "s".
	 * 
	 * @param s
	 * 			The symbol to be used to select the Derivation's nodes to which add the function "f" and the value "v".
	 * 			A null function is added if the node with the element e (that has associated the symbol "s") is the root.
	 * 
	 * @param s2_pos
	 * 			 The absolute position of the node with the element e2 is obtained: abs_pos_node_with_element_e + s2_pos. 
	 *           This node must be at the same level of the node with the element e. Remember that the absolute positions 
	 *           of the nodes start at 0.
	 *           If the obtained position for the node with the element e2 is invalid, a null function is added to this
	 *           node.
	 * 
	 * @throws GrammarExceptionImpl
	 * @throws GrammarMaxDepthExceptionImpl
	 * 
	 */
	public Derivation getMaxRandomDerivationWithFunction(int maxDepthGlobal, NonTerminal nt, Map<String, Double> features,
            											 Function F, String s, int s2_pos) throws GrammarExceptionImpl, 
            											                                         GrammarMaxDepthExceptionImpl;
	
	
	/**
	 * 
	 * The function implements a merge of two m-Trees, using the GBX algorithm described in "Crossover and Mutation Operators for 
	 * Grammar-Guided Genetic Programming" as a guide.
	 * 
	 * @param d1
	 * 			  The first Derivation (m-Tree) used for the merge.
	 * 
	 * @param d2
	 * 			 The second Derivation (m-Tree) used for the merge.
	 * 
	 * @param maxDepthGlobal
	 * 						 The new m-Trees generated by the merge aren't allowed to surpass the depth maxDepthGlobal.
	 * 
	 * @return
	 * 			Two new Trees generated by the merge between the m-Trees d1 and d2.
	 * 
	 */
	public Derivation [] crossoverGBX(Derivation d1, Derivation d2, int maxDepthGlobal) throws GrammarExceptionImpl;
	
	 
	/**
	 * 
	 * The function has the same behavior that the function "crossoverGBX", and it has been added with the following 
	 * additional feature: it updates the nodes that have an Element with a symbol "s" (those nodes have associated a 
	 * function f and a value v). The node's update is the following: the function f associated to the node is updated
	 * ( f2 =f.updateFunction ), and f2 (that sustitutes f in the node), is applied over v ( v2 = f2.applyFuntion[v] ),
	 * and the returning new value v2, sustitutes v in the node.
	 * 
	 * 
	 * @param d1
	 * 			The first Derivation (m-Tree) used for the merge.
	 * 
	 * @param d2
	 * 			The second Derivation (m-Tree) used for the merge.
	 * 
	 * @param maxDepthGlobal
	 * 						 The new m-Trees generated by the merge aren't allowed to surpass the depth maxDepthGlobal.
	 * 
	 * @param s
	 * 		    The symbol to be used to select the Derivation's nodes that have associatet the function "f" and the 
	 *          value "v".		
	 *          
	 * @return
	 * 			Two new Trees generated by the merge between the m-Trees d1 and d2.          	 
	 * 
	 * @throws GrammarExceptionImpl
	 * 
	 */
	public Derivation [] crossoverGBXWithFunction(Derivation d1, Derivation d2, int maxDepthGlobal, String s) throws GrammarExceptionImpl;
	
	
	/**
	 * 
	 * The function prints for each m-Tree's level (from the level 1 to maximum level), the nodes from the 
	 * left to the right (a new level is started when the nodes from the level before are finished). The information
	 * printed for each node is the associated symbol and the production that generates the node.
	 *
	 */
	public void crossByLevels();
	
	/**
	 * 
	 * The function prints for each m-Tree's level (from the level 1 to maximum level), the nodes from the 
	 * left to the right (a new level is started when the nodes from the level before are finished). The information
	 * printed for each node is the associated symbol, the function (if the node has one) operator and increment, the
	 * value associated to the node, and the production that generates the node.
	 * 
	 * @param s
	 * 			The node's symbol of the nodes with a Function.
	 *
	 */
	public void crossByLevelsWithFunction(String s);
	
	
	/**
	 * 
	 * The function returns the maximum level (the root is at the level 1) of the m-Tree that is the Derivation.
	 * 
	 * 
	 */
	int depth();
	
		
	/**
	 * 
	 * As a Derivation is a m-Tree, the Tree has levels . The level start with 1 (the root has the level 1, all 
	 * the root's direct childs have level 2, and so on).
	 * Each node in a level has a relative rank and an absolute rank, for example if the root (level 1) has two 
	 * direct childs A and B (at the level 2), and these childs have the childs A1, A2 (at the level 3), and B1, 
	 * B2 (at the level 3) respectively.  The child A1 has the relative (regards his parent) rank 0, and the 
	 * absolute (regards his level) rank 0, the child A2 has the relative rank 1, and the absolute rank 1, the
	 * child B1 has the relative rank 0, and the absolute rank 2, and the child B2 has the relative rank 1 and
	 * the absolute rank 3.
	 * It's important to note that is possible to find without ambiguity any node of a m-Tree with his level and
	 * absolute rank (these numbers are the node's coordinates in the Tree).
	 * 
	 * The function creates a new Tree, that is a duplicate of the subtree that starts with the node located
	 * at the given level and absolute rank (the new Tree has these node as a root).
	 * 
	 * @param level
	 * 		  		The level where the node to be used as a root is located.
	 * 
	 * @param absRank
	 * 				  The absolute rank (regards the given level) where the node to be used as a root is located.
	 * 
	 * 
	 */
	public Derivation duplicateDerivation(int level, int absRank) throws GrammarExceptionImpl;
	
	
	/**
	 * 
	 * Given an Derivation's Element (e), the function prints where is located in the m-Tree that is the
	 * Derivation. The location is given for the level and absolute rank's Element (e).
	 * 
	 * @param e
	 * 			The Derivation's Element for whom its position is calculated.
	 * 
	 */
	public void getLevelsRanks(Element e);
	
	
	/**
	 * 
	 * As a Derivation is a m-Tree (a Tree where each node has several nodes), the function returns the 
	 * Derivation's leaves from left to right.
	 * 
	 * @return
	 * 			A Collection with the Derivation'leaves from left to right.
	 * 
	 */
	public Collection<Element> getLeavesInLeftOrder() throws GrammarExceptionImpl;
	
	
	/**
	 * 
	 * As a Derivation is a m-Tree (a Tree where each node has several nodes), the function returns the 
	 * Derivation's leaves from left to right.
	 * 
	 * @param s
	 * 				 For the leaves which has an element "e" with the symbol "s" associated, the function
	 *               substitutes the element "e" for a new element "e2" which has as a symbol the value
	 *               associated to the element "e".
	 * 
	 * @return
	 * 			A Collection with the Derivation'leaves from left to right.
	 * 
	 */
	public Collection<Element> getLeavesInLeftOrderWithFunction(String s) throws GrammarExceptionImpl;
	
	
	/**
	 * 
	 * Returns an unique number that identifies biunivocally the Derivation.
	 * 
	 * Returns null if the signature wasn´t calculated.
	 * 
	 * It is a mapping function between the Derivation space and the Real space.
	 *   
	 *   
	 *  
	 **/
	public Double getSignature();
	
	
	/**
	 * 
	 * Clear the structures used by the Derivation Object.
	 * 
	 * @throws GrammarExceptionImpl
	 */
	public void clearDerivation() throws GrammarExceptionImpl;
	
	
	/**
	 * 
	 * Clear the structures used by the Derivation Object.
	 * 
	 * @param symbol
	 * 				  The symbol associated to a node with a Function.
	 * 
	 * @throws GrammarExceptionImpl
	 */
	public void clearDerivationWithFunction(String symbol) throws GrammarExceptionImpl;
	
}
